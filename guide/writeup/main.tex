\newif\ifdraft\drafttrue
\newif\ifcamera\camerafalse
\newif\iffull\fullfalse
\newif\ifcolor\colorfalse

\documentclass{article}

\usepackage{xcolor}
\usepackage{tikz}
\usetikzlibrary{plotmarks}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{src2tex}
\usepackage{syntax}
\usepackage{rotating}
\usepackage{balance}
\usepackage{url}

\ifcolor
\usepackage[colorlinks=true,linkcolor={pennblue},citecolor={pennred}]{hyperref}
\else
\usepackage[colorlinks=true,linkcolor={black},citecolor={black},urlcolor={black}]{hyperref}
\fi

\definecolor{cornellred}{RGB}{179,27,27}
\definecolor{pennblue}{cmyk}{1,.65,0,.3}
\definecolor{pennred}{cmyk}{0,1,.65,.34}

\newcommand{\finish}[2][cornellred]{\ifdraft\textcolor{#1}{\textbf{[#2]}}\fi}
\newcommand{\jnf}[1]{\finish[cornellred]{#1 --JNF}}
\newcommand{\dpw}[1]{\finish[cornellred]{#1 --DPW}}
\newcommand{\arjun}[1]{\finish[cornellred]{#1 --ARJUN}}

\newcommand{\code}[1]{\texttt{#1}}

\newcommand{\eg}{\emph{e.g.}}
\newcommand{\ie}{\emph{i.e.}}
\newcommand{\etc}{\emph{etc.}}


\newcommand{\tutorialdir}{\texttt{tutorial directory}}
\newcommand{\manualref}{\texttt{manual}}



\usepackage{local}

\title{Frenetic Tutorial}

\author{Team Frenetic}

\begin{document}

\maketitle

\section{OpenFlow Programming with Ox}

- OpenFlow: controller sends and receives messages (plaigarize from Frenetic
  ICFP paper, IMO.)

- Ox: you write event handlers, it calls your handlers, etc.

\subsection{Our Example Network}

- Gotta use tikzee

\subsection{Example 1: Repeater and Firewall}

- Step 1: just AllPorts. 
  Emit PacketOut messages, in response to PacketIn messages

- Step 2: Filter out incoming SSH traffic at switch to untrusted host
  Give students a program that filters out all SSH traffic, as an example

- Step 3: emit a flow table for step 1 above

- Step 4: emit a flow table for step 2 above

\subsection{Example 2: Monitoring}

- Step 1: count the volume of traffic sent to host X 
  (and the old policy still holds)

\subsection{Example 2: Efficient Repeater and Firewall}


\subsection{Example 3: Naive Learning Switch}

- Just one switch

\subsection{Example 4: Efficient Learning Switch}

- Emit rules, show

\subsection{Example 5: Learning Switch and Monitoring}

- Also count the volume of traffic sent to host X

\section{Introduction}

The goal of this tutorial is to teach readers how to program a
Software-Defined Network (SDN) running OpenFlow using the Frenetic
programming language.  This involves explaining the syntax and
semantics of Frenetic and illustrating its use on a number of simple
examples.  Along the way, there are a number of exercises for the
reader.  

We encourage the reader to try executing the tutorial examples and exercises
on the tutorial VM that we provide.

\dpw{insert url for tutorial VM and instructions for downloading the VM.  
Tell the reader to start up the VM and to cd to the \tutorialdir{} on the
machine, which will have a set of program example files, stubs for exercises
and topologies ready to go in that directory.  Get the reader to execute
a simple test script to make sure everything is working properly.}

\section{Motivation}

\dpw{Plagiarized in part from IEEE overview paper.}

Traditional networks are built out of special-purpose devices running
distributed protocols that provide functionality such as routing,
trafﬁc monitoring, load balancing, NATing and access control. These
devices have a tightly-integrated control and data plane, and network
operators must separately conﬁgure every protocol on each individual
device. This configuration task is a challenging one as network
operators must struggle with a host of different baroque, low-level,
vendor-specific configuration languages.  Moreover, the pace of
innovation is slow as device internals and APIs are often private and
proprietary, making it difficult to develop new protocols or
functionality to suit client needs.

Recent years, however, have seen growing interest in software-deﬁned
networks (SDNs), in which a logically-centralized controller manages
the packet-processing functionality of a distributed collection of
switches. SDNs make it possible for programmers to control the
behavior of the network directly, by conﬁguring the packet-forwarding
rules installed on each switch.  Moreover, the Open Networking
Foundation is committed to developing a standard, open, vendor-neutral
protocol for controlling collections of switches.  This protocol is
OpenFlow.

SDNs can both simplify existing applications and also serve as a
platform for developing new ones. For example, to implement
shortest-path routing, the controller can calculate the forwarding
rules for each switch by running Dijkstra’s algorithm on the graph of
the network topology instead of using a more complicated distributed
protocol. To conserve energy, the controller can selectively shut down
links or even whole switches after directing trafﬁc along other
paths. To enforce ﬁne-grained access control policies, the controller
can consult an external authentication server and install custom
firewall rules.

But although SDNs makes it possible to program the network, they do
not make it easy. Protocols such as OpenFlow expose an interface that
closely matches the features of the underlying switch
hardware. Roughly speaking, OpenFlow allows programmers to manually
install and uninstall individual packet-processing rules.
First-generation controller systems such as NOX, Beacon, and
Floodlight support the same low-level interface, which forces
applications to be implemented using programs that manipulate the
fine-grained state of individual devices.  Unfortunately, it is
extremely difficult to develop independent program components, such as
a router, firewall and network monitor, that collaborate to control
the flow of traffic through a network since the application must
ultimately install a \emph{single} set of low-level rules on the underlying
switches.  This single set of rules must simultaneously implement the
desired high-level semantics for each independent high-level
component.

In addition, a network is a distributed system, and all of the usual
complications arise—in particular, control messages sent to switches
are processed asynchronously. Programming asynchronous, distributed
systems is notoriously difficult and error prone.  Network programmers
require require support to get this right.

The goal of the Frenetic language is to raise the level of abstraction
for programming SDNs. To replace the low-level imperative interfaces
available today, Frenetic offers a suite of declarative abstractions
for querying network state, deﬁning forwarding policies, and updating
policies in a consistent way.  These constructs are designed to be
\emph{modular} so that individual policies can be written in isolation, by
different developers and later composed with other components to
create sophisticated policies. This is made possible in part by the
design of the constructs themselves, and in part by the underlying
run-time system, which implements them by compiling them down to
low-level OpenFlow forwarding rules.  Our emphasis on modularity and
composition—the foundational principles behind effective design of any
complex software system—is the key feature that distinguishes Frenetic
from other SDN controllers.

\section{Programming Static Network Policies}

\dpw{I'm going to describe policies a functions producing sets of packets.
Kill me later?}

A Frenetic policy describes how a collection of switches
forwards packets from one location to another.  We call a Frenetic policy
\emph{static} when it is fixed ahead of time,
does not change, and does not depend upon the packets flows that
appear in the network.  We focus on static policies in this
section of the tutorial.

The Frenetic programming paradigm encourages users to think of static
policies as abstract \emph{functions} and to ignore how these functions
are actually implemented on switch hardware.  Our compiler will take
care of implementing the functions --- programmers need only concern
themselves with specifying the right functionality.  

More specifically, each policy is a function
from a \emph{located packet} to a set of new \emph{located packets}.
A \emph{located packet} is simply a record that contains one
field for each OpenFlow-supported packet header (\code{srcMac}, \code{dstMac},
\code{vlan}, \code{srcIP}, \code{dstIP}, \code{tcpSrcPort}, \code{tcpDstPort}, 
\code{frameType}) as well as fields specifying the packet location 
in the network (\code{switch} and \code{inPort}).

To understand how a packet flows through a network, a programmer must
analyze both the current Frenetic policy $P$ and the network topology
$T$.  The policy is a function that explains how a switch should move
a packet from an input port to an output port.  The topology is a
function that explains how a packet moves from the outport of one
switch, across a link, to the inport of some other switch.  Hence,
given a located packet $p_0$, we can trace its path through the
network by first applying the policy function $P(p_0)$, generating a
set of (possibly zero) packets $\{p_1,\ldots,p_k\}$ at outports on a
switch.  For simplicity, let's assume the result $P(p_0)$ contains
just one packet ($p_1$) (\ie, it is a normal forwarding policy, not a
broadcast).  Next, we apply the topology function $T$ to generate a
packet $p_1'$ accross the other side of the link at some new switch.
Then we apply the policy function $P$ again: $P(p_1')$ generating some
further set of results.  And apply the topology function $T$ to each
element of that result set.  In summary, one traces the flow of
packets through a network by alternately applying the policy function
$P$ and the topology function $T$.

The bottom line is that (static) Frenetic is just a domain-specific
language for writing down functions that determine how switches
forward packets.

\subsection{Introductory Examples}

Static Frenetic is a small language consisting entirely of the following
features:

\begin{itemize}
\item a set of primitive \emph{actions}, which allow programmers to modify and 
forward packets
\item \emph{conditional statements}, which allow programmers to perform 
different actions on different kinds of packets
\item  \emph{sequencing}, which allows programmers to perform a series of
transformations on a packet, and
\item \emph{parallel composition}, which allows programmers to do more
than one thing on a packet --- perhaps forwarding the packet to two 
different locations.
\end{itemize}

\subsubsection{Example 1: A Repeater}

To begin, consider a network with just one switch.  Assume that switch 
has two ports, numbered 1 and 2.  Our first goal will be to program
a repeater --- a simple switch that forwards all packets coming in port 1
out port 2 and vice versa.  The following policy accomplishes that task.

\begin{progeg}
let repeater =
  if inPort = 1 then fwd(2)
  else fwd(1)
\end{progeg}

The \code{let} keyword introduces a new policy, which we have chosen to call 
\code{repeater}.  An \code{if}-\code{then}-\code{else} statement determines
whether to forward a packet out port 1 or port 2, depending on the packet's
\code{inPort} field.  In addition to testing the packet's \code{inPort}, 
if statement predicates can refer to
the \code{switch} 
at which a packet arrives, as well as any of the OpenFlow-supported
fields, such as the \code{srcIP}, \code{dstIP} or \code{frameType}.  
Conditions can also be formed using 
conjunctions (\code{\&\&}), disjunctions
(\code{||}) and negation (\code{!}) of other conditions.
See the \manualref{} for the complete list of predicates. 

\dpw{The following commands are essentially made up.  Will have to rejigger.}
Now, let's test the program to see what it does.  In the \tutorialdir{},
you will see a file named \code{tut1.nc}, which contains the
repeater program.  Start up the Frenetic controller program by 
executing the following command at the prompt.

\begin{progeg}
> ./frenetic tut1.nc
\end{progeg}
%
Now start up mininet:
%
\begin{progeg}
> sudo mn controller=remote
\end{progeg}
%
Mininet will start up with a single switch and two hosts, 
\code{h1} and \code{h2}, connected to the two ports on the switch.
You should see the following message:
%
\begin{progeg}
...
\end{progeg}
%
At the mininet prompt, test your repeater program using ping:
%
\begin{progeg}
mininet> h1 ping h2
\end{progeg}
%
You should see the following trace:
%
\begin{progeg}
...
\end{progeg}
%
Hit \code{ctrl-C} when you have seen enough.

\subsubsection{Example 2: Simple Network Address Translation}

Next, let's adapt our first example so that instead of simply acting
as a repeater, it does some static address translation for us as well.
We will transform packets destined for IP address 10.0.0.1 entering the 
switch at port 1 in to packets destined for IP address 10.0.0.101.
In the other direction, we will translate source IP addresses from
10.0.0.101 to 10.0.0.1.  Now, our example.
%
\begin{progeg}
let natter =
  if inPort = 1 then
    (if dstIP = 10.0.0.1 then dstIP := 10.0.0.101 else pass); 
    fwd(2)
  else 
    (if srcIP = 10.0.0.101 then srcIP := 10.0.0.1 else pass); 
    fwd(1)
\end{progeg}
%
As the reader can see, packet modifications are implemented using
assignment actions, which have the following form.
%
\begin{progeg}
field := constant
\end{progeg}
%
Above \code{field} may be any OpenFlow-supported field (such as 
\code{srcMac}, \code{srcIP} or others).  The constant must have the
appropriate form.  For instance, when assigning to the \code{srcIP}
field, the constant must be an ip-address with the form 
\code{xxx.xxx.xxx.xxx}.  See the manual for the syntax of other
constants.

The semi-colon may be used to sequence any series of primitive actions
or, more generally, any series of policies.  For instance, above, the policy
%
\begin{progeg}
if dstIP = 10.0.0.1 then dstIP := 10.0.0.101 else pass
\end{progeg}
%
is placed in sequence with the action
%
\begin{progeg}
fwd(2)
\end{progeg}
%
The first policy fragment modifies packets destined for 10.0.0.1 and leaves
all other packets unchanged --- the \code{pass} primitive is the identity
transformation on packets (and it turns out to be quite useful in
combination with sequencing). The second policy fragment 
forwards all packets out port 2 regardless
of destination IP.  When sequenced, some packets are modified, some left
untouched, and all are forwarded.

\subsubsection{Example 3: Debugging}

A useful way to debug a network policy is to examine packets as they
flow through the network.  In static Frenetic, it is possible to add 
\emph{queries} to a program.  These queries can select subsets of packets,
send them to the controller and print them to your screen.  As
an example, suppose we would like to check that address translation 
is happening correctly in our previous example.  Intuitively, we now
want to send packets in two different directions \emph{at the same time}:
(1) we want to continue forwarding packets as before, and (2) we want
a separate copy of a packet to be sent to the controller for printing.
To do both these actions requires a new policy combinator: 
\emph{parallel composition} (\code{+}).  Intuitively, the parallel
composition \code{P1 + P2} executes both \code{P1} and \code{P2}
on the input packet at the same time, returning the union of the results.
Code to monitor the results of natting appears below.
%
\begin{progeg}
let natter\_debug = 
  natter + (if outport = 2 then monitor\_sw())
\end{progeg}
%


\subsubsection{Example 4: Multiple Switches}
Illustrate multiple switches.  Use two switches.  Do destination-based
IP routing.  Show how to handle arp.  Show a parameterized policy.
Run mininet in a different topology.

\subsubsection{Example 5:  Add a Firewall}

\subsection{Semantics}

Evaluation Semantics.

\subsection{Summary of Concepts}

Give pointer to the manual.

\subsection{Exercises}

Review the new topology with 5 switches.  

The following parameterized policy may be useful in completing the
exercises.

\begin{progeg}
let arpify (P:policy) =
  if frameType = arp then all
  else P
\end{progeg}

\noindent
\begin{enumerate}
\item Write a program to route all IP traffic as follows: 
\begin{itemize}
  \item packets with destination ip 10.0.0.10 arriving at switch C go to host 10.  
  \item packets with destination ip 10.0.0.20 arriving at switch C go to host 20.  
  \item packets with destination ip 10.0.0.30 arriving at switch D go to host 30.  
  \item packets with destination ip 10.0.0.40 arriving at switch D go to host 40.  
  \item flood all arp packets arriving at any switch
\end{itemize}
Try out your program by pinging 10 from 20 and 20 from 10.  What happens?
What happens if you ping 10 from 30?

\item
Extend the program written in (a) to route all traffic between
10, 20, 30, 40, 50 assuming these hosts have IP addresses 
10.0.0.10, 10.0.0.20, 10.0.0.30, 10.0.0.40, and 10.0.0.50.

\item Use the NetCore query facility to discover the set of all TCP ports 
being used by either machines 10 or 20.  Here is a [list of common port
numbers](http://packetlife.net/media/library/23/common-ports.pdf)
Note: some protocols are sending a lot of traffic (eg: HTTP, on port
80).  As you investigate, narrow your searches to find the "needle in
the haystack."  There is one host sending a small amount of traffic to
a non-standard port in a nonstandard format.  Which host is it?  Print
the packets using that port.  They contain a secret message.

\item Construct a firewall for the network that enforces the following policy.
Compose it with the routing policy defined in part 2.
\begin{itemize}
  \item Machines 10, 20, 30, 40 are trusted machines.  
  \item Machine 50 is an untrusted machine.  
  \item Each of these machines is serving files using HTTP (TCP port 80).  
  \item Machines 10 and 20 have private files that may not be read by untrusted machines using HTTP.  
  \item Machines 30, 40, 50 have public files that may be read by any machine.
  \item All traffic not explicitly prohibited must be allowed to pass through the network.
\end{itemize}
\end{enumerate}

\section{Dynamic Frenetic Examples}

\paragraph*{Acknowledgements.}
%
This work is supported in part by the NSF under grant
CNS-1111698, the ONR under award N00014-12-1-0757, and by a Google
Research Award.

{
\bibliographystyle{abbrvnat} % We recommend abbrvnat bibliography style.
\bibliography{main}
}
\end{document}
